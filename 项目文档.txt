# 项目更新文档

## [增强] 全面提升对Google Gemini等非标准API端点的兼容性

- **问题描述**: 先前的修复虽然解决了部分URL拼接问题，但对于像Google Gemini API（`https://generativelanguage.googleapis.com/v1beta/openai/`）这类采用非标准路径（不含`/v1`）的端点，兼容性依然不足。
- **核心需求**: 使插件能够智能地处理任何给定的基础URL，无论是标准的OpenAI格式、还是Google Gemini等特殊格式，都能正确地拼接上 `/chat/completions` 或 `/models` 路径。
- **解决方案**:
    1.  **重构所有前端URL逻辑**: 对 `core/api.js` 中的 `callApiViaFrontend`, `fetchModels`, 和 `testApiConnection` 三个函数的前端模式URL构建逻辑进行了彻底重构。
    2.  **移除硬编码依赖**: 新的逻辑不再依赖于检查URL中是否包含 `/v1` 字符串。
    3.  **实现通用拼接规则**:
        -   对于聊天（`chat/completions`）和测试（`test`）请求，新的逻辑会确保最终URL以 `/chat/completions` 结尾。如果用户提供的基础URL没有这个后缀，它会自动被添加。
        -   对于获取模型（`models`）的请求，逻辑会首先检查URL是否以 `/chat/completions` 结尾，如果是，则智能地将其替换为 `/models`。否则，如果URL不以 `/models` 结尾，它会自动拼接上 `/models`。
- **操作代码**:
    - `core/api.js` (以 `fetchModels` 为例):
        ```javascript
        // 旧的、基于 /v1 的复杂逻辑已被替换

        // 新的通用URL构建逻辑:
        let modelsUrl = apiUrl.replace(/\/$/, ''); // 移除末尾斜杠
        // 如果用户可能输入了完整的 chat completions 地址，则智能替换
        if (modelsUrl.endsWith('/chat/completions')) {
            modelsUrl = modelsUrl.replace(/\/chat\/completions$/, '/models');
        }
        // 否则，如果不是 /models 结尾，则假定为基础URL并拼接 /models
        else if (!modelsUrl.endsWith('/models')) {
            modelsUrl += '/models';
        }
        ```
- **效果**: 插件前端直连模式的API兼容性得到极大提升。现在它可以无缝对接各种遵循OpenAI接口规范的API，包括但不限于标准OpenAI、Azure OpenAI、Google Gemini、Groq以及其他本地部署的模型服务，无需用户进行复杂的URL调整。

## [BUG修复] 修复前端直连模式获取模型列表404的问题

- **问题描述**: 在前端直连（Frontend）模式下，当API URL设置为 `https://api.siliconflow.cn/v1` 时，点击“获取模型”按钮会触发一个 `404 Not Found` 错误。
- **根本原因**: `core/api.js` 中的 `fetchModels` 函数在构建请求URL时逻辑不够完善。它错误地将 `https://api.siliconflow.cn/v1` 作为最终请求地址，而正确的地址应该是 `https://api.siliconflow.cn/v1/models`。
- **解决方案**:
    1.  **重构URL构建逻辑**: 对 `core/api.js` 文件中的 `fetchModels` 函数进行了修改。
    2.  **增强URL处理能力**: 引入了更严谨的URL处理逻辑。新的代码会先移除URL末尾的斜杠，然后检查URL是否包含 `/v1`。
        -   如果URL以 `/v1/chat/completions` 结尾，则智能替换为 `/v1/models`。
        -   如果URL以 `/v1` 结尾或包含 `/v1` 但不是以 `/models` 结尾，则自动追加 `/models`。
        -   如果URL不包含 `/v1`，则按默认规则拼接 `/v1/models`。
- **操作代码**:
    - `core/api.js`:
        ```javascript
        // 旧的URL构建逻辑:
        // const modelsUrl = apiUrl.includes('/v1') ? apiUrl.replace(/chat\/completions$/, 'models') : apiUrl.replace(/\/$/, '') + '/v1/models';

        // 新的、更健壮的URL构建逻辑:
        let modelsUrl = apiUrl.replace(/\/$/, ''); // 移除末尾斜杠
        if (modelsUrl.includes('/v1')) {
            // 如果是 /v1/chat/completions 结尾，替换为 /models
            if (modelsUrl.endsWith('/chat/completions')) {
                modelsUrl = modelsUrl.replace(/\/chat\/completions$/, '/models');
            } 
            // 如果只是 /v1 结尾，或者其他 /v1/... 结尾，但不是/models, 则拼接 /models
            else if (!modelsUrl.endsWith('/models')) {
                modelsUrl += '/models';
            }
        } else {
            // 如果不包含 /v1，则视为标准情况，拼接 /v1/models
            modelsUrl += '/v1/models';
        }
        ```
- **效果**: 彻底解决了前端直连模式下获取模型列表时的URL拼接错误。插件现在可以正确处理各种格式的API URL，确保总能向正确的 `/models` 端点发出请求，提高了对不同API服务的兼容性。

## [BUG修复] 修复插件UI样式影响酒馆全局界面的问题

- **问题描述**: 插件设置界面中的UI元素（如输入框、滑动开关、滑块等）的自定义颜色和样式，会意外地应用到SillyTavern的全局界面上，干扰了其他部分的正常显示。
- **根本原因**: `style.css` 文件中存在多个过于宽泛的CSS选择器。例如，`.text_pole`, `.toggle-switch`, `input[type="range"]` 等选择器会匹配整个HTML文档中的所有相应元素，而不仅仅是本插件内部的元素，从而导致样式“泄露”。
- **解决方案**:
    1.  **限定CSS作用域**: 对 `style.css` 文件进行了全面的审查和修改。
    2.  **添加父级ID选择器**: 为所有可能产生冲突的CSS规则，都增加了父级ID选择器 `#qrf_settings_panel` 作为前缀。例如，将 `.text_pole` 修改为 `#qrf_settings_panel .text_pole`。
    3.  **确保隔离**: 这一修改确保了所有的自定义样式都只在ID为 `qrf_settings_panel` 的元素（即插件的设置面板）内部生效，无法影响到面板之外的任何SillyTavern原生UI组件。
- **操作代码**:
    - `style.css`:
        ```css
        /* 将所有通用选择器限定在插件面板内 */
        
        /* 例如，旧规则: */
        /* .text_pole { ... } */
        
        /* 新规则: */
        #qrf_settings_panel .text_pole { ... }

        /* 例如，旧规则: */
        /* input[type="range"] { ... } */

        /* 新规则: */
        #qrf_settings_panel input[type="range"] { ... }
        ```
- **效果**: 彻底解决了UI样式全局污染的问题。插件的设置界面现在拥有完全独立的样式作用域，其外观调整不再对SillyTavern主程序的任何其他部分产生副作用，保证了整体的视觉一致性和稳定性。

## [架构重构] 全面采用记忆插件(st-memory-enhancement)的后端代理API逻辑

- **问题描述**: 即便修复了前端URL的拼接问题，插件的API调用逻辑与成熟的记忆插件相比，在健壮性和兼容性上仍有差距。特别是它直接调用 `ChatCompletionService` 的方式，可能不如通过SillyTavern官方后端路由进行代理稳定。
- **核心需求**: 为解决潜在的各种网络问题（如CORS、复杂端点），将插件的API调用方式，完全重构为与 `st-memory-enhancement` 一致的、通过 `$.ajax` 调用酒馆后端路由的模式。
- **解决方案**:
    1.  **分析核心模板**: 深入分析了 `st-memory-enhancement/scripts/settings/standaloneAPI.js` 的实现。
    2.  **API模块彻底重写 (`core/api.js`)**:
        -   完全移除了对 `ChatCompletionService` 的直接依赖。
        -   重写了 `callApiViaBackend`、`fetchModels` 和 `testApiConnection` 三个函数中处理后端代理模式的逻辑。
        -   现在，所有后端代理请求都通过 `$.ajax`，向 SillyTavern 的标准后端API端点（`/api/backends/chat-completions/generate` 和 `/api/backends/chat-completions/status`）发送 `POST` 请求。
        -   请求体中包含了 `custom_url` 和 `api_key`，由SillyTavern后端负责安全地转发给最终的API服务。
    3.  **保留前端优化**: 对于前端直连模式 (`frontend`)，保留了之前已修复的、更智能的URL判断逻辑，使其优于 `st-memory-enhancement` 的实现。
- **操作代码**:
    - 对 `core/api.js` 文件执行了 `write_to_file` 操作，用完全重构后的、基于后端代理的新逻辑替换了所有旧代码。
        ```javascript
        // core/api.js - 后端模式下的新实现
        rawResponse = await $.ajax({
            url: '/api/backends/chat-completions/generate', // 或 /status
            type: 'POST',
            contentType: 'application/json',
            headers: { 'Authorization': `Bearer ${apiKey}` },
            data: JSON.stringify({
                // ...
                chat_completion_source: 'custom',
                custom_url: apiUrl,
                api_key: apiKey,
            }),
        });
        ```
- **效果**: 插件的网络请求架构得到了根本性的提升。通过利用SillyTavern成熟的后端代理机制，API调用的**稳定性、安全性**和**兼容性**都达到了与核心插件（如记忆插件）同等的水平，彻底解决了包括 `ETIMEDOUT` 在内的各种潜在网络问题。

## [BUG修复] 修复因URL拼接错误导致的API请求超时 (ETIMEDOUT)

- **问题描述**: 插件在尝试连接外部API（特别是像 Google Generative AI 这样的非标准端点）时，发生 `FetchError: request to ... failed, reason: ETIMEDOUT` 错误。
- **根本原因**: `core/api.js` 中用于前端直连模式的 URL 构建逻辑过于死板。它强制性地移除了用户提供 URL 中的 `/v1` 并重新拼接上标准路径（如 `/v1/models` 或 `/v1/chat/completions`），导致向 `https://generativelanguage.googleapis.com/v1beta/openai` 这样的地址发出了错误的请求，从而引发连接超时。
- **解决方案**:
    1.  **重构URL构建逻辑 (`core/api.js`)**:
        -   修改了 `callApiViaFrontend`, `fetchModels` 和 `testApiConnection` 三个函数中所有处理前端模式 URL 的代码。
        -   新的逻辑会首先检查用户提供的 `apiUrl` 是否已经包含了 `/v1` 字符串。
        -   如果包含，则直接使用用户提供的 URL（或进行最小程度的必要修改，如将 `chat/completions` 替换为 `models`），不再进行强制拼接。
        -   如果不包含，则沿用旧的拼接逻辑作为默认行为。
- **操作代码**:
    - `core/api.js`:
        ```javascript
        // 在 callApiViaFrontend, fetchModels, testApiConnection 等函数中
        // 将旧的URL构建方式：
        // const finalApiUrl = apiUrl.replace(/\/$/, '').replace(/\/v1$/, '') + '/v1/chat/completions';
        
        // 修改为新的智能判断方式：
        const finalApiUrl = apiUrl.includes('/v1') ? apiUrl : apiUrl.replace(/\/$/, '') + '/v1/chat/completions';

        // 对 modelsUrl 也做了类似修改
        const modelsUrl = apiUrl.includes('/v1') ? apiUrl.replace(/chat\/completions$/, 'models') : apiUrl.replace(/\/$/, '') + '/v1/models';
        ```
- **效果**: 插件现在能够正确处理各种包含 `/v1` 或 `/v1beta` 等变体的 API 端点，大大提高了对不同 API 服务（尤其是非 OpenAI 标准服务）的兼容性，从根本上解决了超时错误。

## [文档] 创建论坛发布帖子

- **任务描述**: 根据 `论坛帖子草稿.txt` 和详细的 `项目文档.txt`，为插件撰写一篇引人入胜的、用于在论坛发布的宣传帖子。
- **核心需求**: 帖子需要融合技术实现的亮点和市场宣传的吸引力，全面展示插件的强大功能，如两步式AI剧情引擎、动态世界书、高度灵活性等。
- **解决方案**:
    1.  **分析输入**: 深入分析了 `论坛帖子草稿.txt` 的核心创意和 `项目文档.txt` 中记录的完整功能迭代历史。
    2.  **提炼亮点**: 将复杂的技术实现（如 `onGenerationAfterCommands` 拦截、递归世界书、双模式API等）提炼为用户易于理解的核心卖点（如“AI编剧团队”、“动态世界书”）。
    3.  **撰写帖子**: 撰写了一篇全新的、结构清晰、语言富有感染力的帖子，并将其保存到 `论坛发布帖子.md` 文件中。
- **操作代码**:
    - `write_to_file`:
        ```xml
        <write_to_file>
        <path>论坛发布帖子.md</path>
        <content>
        ... (帖子内容已省略) ...
